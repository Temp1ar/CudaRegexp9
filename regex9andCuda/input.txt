  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
asd
asd
  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good! 2/12/2004

  The disadvantages of a CLASS II system are:
asd
asd
  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
asd
asd
  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
asd
asd
  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good! 2/12/2004

  The disadvantages of a CLASS II system are:
asd
asd
  6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
    6.  FAQ


     Q1.
        Is there any single figure of merit for Linux systems ?

     A: No, thankfully nobody has yet come up with a Lhinuxstone (tm)
        measurement. And if there was one, it would not make much sense:
        Linux systems are used for many different tasks, from heavily
        loaded Web servers to graphics workstations for individual use.
        No single figure of merit can describe the performance of a
        Linux system under such different situations. 5/10/00

     Q2.
        Then, how about a dozen figures summarizing the performance of
        diverse Linux systems ?

     A: That would be the ideal situation. I would like to see that come
        true. Anybody volunteers for a Linux Benchmarking Project ? With
        a Web site and an on-line, complete, well-designed reports
        database ?

     Q3.
        ... BogoMips ... ?

     A: BogoMips has nothing to do with the performance of your system.
        Check the BogoMips Mini-HOWTO.

     Q4.
        What is the "best" benchmark for Linux ?

     A: It all depends on which performance aspect of a Linux system one
        wants to measure. There are different benchmarks to measure the
        network (Ethernet sustained transfer rates), file server (NFS),
        disk I/O, FPU, integer, graphics, 3D, processor-memory
        bandwidth, CAD performance, transaction time, SQL performance,
        Web server performance, real-time performance, CD-ROM
        performance, Quake performance (!), etc ... AFAIK no bechmark
        suite exists for Linux that supports all these tests.

     Q5.
        What is the fastest processor under Linux ?

     A: Fastest at what task ? If one is heavily number-crunching
        oriented, a very high clock rate Alpha (600 MHz and going)
        should be faster than anything else, since Alphas have been
        designed for that kind of performance. If, on the other hand,
        one wants to put together a very fast news server, it is
        probable that the choice of a fast hard disk subsystem and lots
        of RAM will result in higher performance improvements than a
        change of processor, for the same amount of $.

     Q6.
        Let me rephrase the last question, then: is there a processor
        that is fastest for general purpose applications ?

     A: This is a tricky question but it takes a very simple answer: NO.
        One can always design a faster system even for general purpose
        applications, independent of the processor. Usually, all other
        things being equal, higher clock rates will result in higher
        performance systems (and more headaches too). Taking out an old
        100 MHz Pentium from an (usually not) upgradable motherboard,
        and plugging in the 200 MHz version, one should feel the extra
        "hummph". Of course, with only 16 MBytes of RAM, the same
        investment would have been more wisely spent on extra SIMMs...

     Q7.
        So clock rates influence the performance of a system ?

     A: For most tasks except for NOP empty loops (BTW these get removed
        by modern optimizing compilers), an increase in clock rate will
        not give you a linear increase in performance. Very small
        processor intensive programs that will fit entirely in the
        primary cache inside the processor (the L1 cache, usually 8 or
        16 K) will have a performance increase equivalent to the clock
        rate increase, but most "true" programs are much larger than
        that, have loops that do not fit in the L1 cache, share the L2
        (external) cache with other processes, depend on external
        components and will give much smaller performance increases.
        This is because the L1 cache runs at the same clock rate as the
        processor, whereas most L2 caches and all other subsystems
        (DRAM, for example) will run asynchronously at lower clock
        rates.

     Q8.
        OK, then, one last question on that matter: which is the
        processor with the best price/performance ratio for general
        purpose Linux use ? 2/12/97

     A: Defining "general purpose Linux use" in not an easy thing ! For
        any particular application, there is always a processor with THE
        BEST price/performance ratio at any given time, but it changes
        rather frequently as manufacturers release new processors, so
        answering Processor XYZ running at n MHz would be a snapshot
        answer. However, the price of the processor is insignificant
        when compared to the price of the whole system one will be
        putting together. So, really, the question should be how can one
        maximize the price/performance ratio for a given system ? And
        the answer to that question depends heavily on the minimum
        performance requirements and/or maximum cost established for the
        configuration being considered. Sometimes, off-the-shelf
        hardware will not meet minimum performance requirements and
        expensive RISC systems will be the only alternative. For home
        use, I recommend a balanced, homogeneous system for overall
        performance (now go figure what I mean by balanced and
        homogeneous :-); the choice of a processor is an important
        decision , but no more than choosing hard disk type and
        capacity, amount of RAM, video card, etc...

     Q9.
        What is a "significant" increase in performance ?

     A: I would say that anything under 1% is not significant (could be
        described as "marginal"). We, humans, will hardly perceive the
        difference between two systems with a 5 % difference in response
        time. Of course some hard-core benchmarkers are not humans and
        will tell you that, when comparing systems with 65.9 and 66.5
        performance indexes, the later is "definitely faster".

     Q10.
        How do I obtain "significant" increases in performance at the
        lowest cost ?

     A: Since most source code is available for Linux, careful
        examination and algorithmic redesign of key subroutines could
        yield order-of-magnitude increases in performance in some cases.
        If one is dealing with a commercial project and does not wish to
        delve deeply in C source code a Linux consultant should be
        called in. See the Consultants-HOWTO.


  7.  Copyright, acknowledgments and miscellaneous


  7.1.  How this document was produced


  The first step was reading section 4 "Writing and submitting a HOWTO"
  of the HOWTO Index by Tim Bynum.

  I knew absolutely nothing about SGML or LaTeX, but was tempted to use
  an automated documentation generation package after reading the
  various comments about SGML-Tools. However, inserting tags manually in
  a document reminds me of the days I hand-assembled a 512 byte monitor
  program for a now defunct 8-bit microprocessor, so I got hold of the
  LyX sources, compiled it, and used its LinuxDoc mode. Highly
  recommended combination: LyX and SGML-Tools.

  7.2.  Copyright


  The Linux Benchmarking HOWTO is copyright (C) 1997 by Andr D. Balsa.
  Linux HOWTO documents may be reproduced and distributed in whole or in
  part, in any medium physical or electronic, as long as this copyright
  notice is retained on all copies. Commercial redistribution is allowed
  and encouraged; however, the author would like to be notified of any
  such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  In short, we wish to promote dissemination of this information through
  as many channels as possible. However, we do wish to retain copyright
  on the HOWTO documents, and would like to be notified of any plans to
  redistribute the HOWTOs.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at linux-howto@sunsite.unc.edu via email.

  7.3.  New versions of this document


  New versions of the Linux Benchmarking-HOWTO will be placed on
  sunsite.unc.edu and mirror sites. There are other formats, such as a
  Postscript and dvi version in the other-formats directory. The Linux
  Benchmarking-HOWTO is also available for WWW clients such as Grail, a
  Web browser written in Python. It will also be posted regularly to
  comp.os.linux.answers.

  7.4.  Feedback


  Suggestions, corrections, additions wanted. Contributors wanted and
  acknowledged. Flames not wanted.

  I can always be reached at andrewbalsa@usa.net.

  7.5.  Acknowledgments


  David Niemi, the author of the Unixbench suite, has proved to be an
  endless source of information and (valid) criticism.

  I also want to thank Greg Hankins one of the main contributors to the
  SGML-tools package, Linus Torvalds and the entire Linux community.
  This HOWTO is my way of giving back.

  7.6.  Disclaimer


  Your mileage may, and will, vary. Be aware that benchmarking is a
  touchy subject and a great time-and-energy consuming activity.

  7.7.  Trademarks


  Pentium and Windows NT are trademarks of Intel and Microsoft
  Corporations respectively.

  BYTE and BYTEmark are trademarks of McGraw-Hill, Inc.

  Cyrix and 6x86 are trademarks of Cyrix Corporation.

  Linux is not a trademark, hopefully never will be.



  Beowulf HOWTO
  Jacek Radajewski and Douglas Eadline
  v1.1.1, 22 November 1998

  This document introduces the Beowulf Supercomputer architecture and
  provides background information on parallel programming, including
  links to other more specific documents, and web pages.
  ______________________________________________________________________

  Table of Contents 5/11/92



  1. Preamble

     1.1 Disclaimer
     1.2 Copyright
     1.3 About this HOWTO
     1.4 About the authors
     1.5 Acknowledgements

  2. Introduction

     2.1 Who should read this HOWTO ?
     2.2 What is a Beowulf ?
     2.3 Classification

  3. Architecture Overview

     3.1 What does it look like ?
     3.2 How to utilise the other nodes ?
     3.3 How does Beowulf differ from a COW ?

  4. System Design

     4.1 A brief background on parallel computing.
     4.2 The methods of parallel computing
        4.2.1 Why more than one CPU?
        4.2.2 The Parallel Computing Store
           4.2.2.1 Single-tasking Operating System
           4.2.2.2 Multi-tasking Operating System:
           4.2.2.3 Multitasking Operating Systems with Multiple CPUs:
           4.2.2.4 Threads on a Multitasking Operating Systems extra CPUs
           4.2.2.5 Sending Messages on Multitasking Operating Systems with extra CPUs:
     4.3 Architectures for parallel computing
        4.3.1 Hardware Architectures
        4.3.2 Software API Architectures
           4.3.2.1 Messages
           4.3.2.2 Threads
        4.3.3 Application Architecture
     4.4 Suitability
     4.5 Writing and porting parallel software
        4.5.1 Determine concurrent parts of your program
        4.5.2 Estimate parallel efficiency
        4.5.3 Describing the concurrent parts of your program
           4.5.3.1 Explicit Methods
           4.5.3.2 Implicit Methods

  5. Beowulf Resources

     5.1 Starting Points
     5.2 Documentation
     5.3 Papers
     5.4 Software
     5.5 Beowulf Machines
     5.6 Other Interesting Sites
     5.7 History

  6. Source code

     6.1 sum.c
     6.2 sigmasqrt.c
     6.3 prun.sh


  ______________________________________________________________________



  1.  Preamble

  1.1.  Disclaimer

  We will not accept any responsibility for any incorrect information
  within this document, nor for any damage it might cause when applied.


  1.2.  Copyright

  Copyright (C) 1997 - 1998 Jacek Radajewski and Douglas Eadline.
  Permission to distribute and modify this document is granted under the
  GNU General Public Licence.


  1.3.  About this HOWTO

  Jacek Radajewski started work on this document in November 1997 and
  was soon joined by Douglas Eadline.  Over a few months the Beowulf
  HOWTO grew into a large document, and in August 1998 it was split into
  three documents: Beowulf HOWTO, Beowulf Architecture Design HOWTO, and
  the Beowulf Installation and Administration HOWTO.  Version 1.0.0 of
  the Beowulf HOWTO was released to the Linux Documentation Project on
  11 November 1998.  We hope that this is only the beginning of what
  will become a complete Beowulf Documentation Project.


  1.4.  About the authors


  o  Jacek Radajewski works as a Network Manager, and is studying for an
     honors degree in computer science at the University of Southern
     Queensland, Australia.  Jacek's first contact with Linux was in
     1995 and it was love at first sight.  Jacek built his first Beowulf
     cluster in May 1997 and has been playing with the technology ever
     since, always trying to find new and better ways of setting things
     up.  You can contact Jacek by sending e-mail to jacek@usq.edu.au

  o  Douglas Eadline, Ph.D. is President and Principal Scientist at
     Paralogic, Inc., Bethlehem, PA, USA.  Trained as
     Physical/Analytical Chemist, he has been involved with computers
     since 1978 when he built his first single board computer for use
     with chemical instrumentation.  Dr. Eadline's interests now include
     Linux, Beowulf clusters, and parallel algorithms.  Dr. Eadline can
     be contacted by sending email to deadline@plogic.com


  1.5.  Acknowledgements

  The writing of the Beowulf HOWTO was a long proces and is finally
  complete, thanks to many individuals.  I would like to thank the
  following people for their help and contribution to this HOWTO.

  o  Becky for her love, support, and understanding.

  o  Tom Sterling, Don Becker, and other people at NASA who started the
     Beowulf project.

  o  Thanh Tran-Cong and the Faculty of Engineering and Surveying for
     making the topcat Beowulf machine available for experiments.

  o  My supervisor Christopher Vance for many great ideas.

  o  My friend Russell Waldron for great programming ideas, his general
     interest in the project, and support.

  o  My friend David Smith for proof reading this document.

  o  Many other people on the Beowulf mailing list who provided me with
     feedback and ideas.

  o  All the people who are responsible for the Linux operating system
     and all the other free software packages used on topcat and other
     Beowulf machines.


  2.  Introduction


  As the performance of commodity computer and network hardware
  increase, and their prices decrease, it becomes more and more
  practical to build parallel computational systems from off-the-shelf
  components, rather than buying CPU time on very expensive
  Supercomputers.  In fact, the price per performance ratio of a Beowulf
  type machine is between three to ten times better than that for
  traditional supercomputers.  Beowulf architecture scales well, it is
  easy to construct and you only pay for the hardware as most of the
  software is free.


  2.1.  Who should read this HOWTO ?

  This HOWTO is designed for a person with at least some exposure to the
  Linux operating system.  Knowledge of Beowulf technology or
  understanding of more complex operating system and networking concepts
  is not essential, but some exposure to parallel computing would be
  advantageous (after all you must have some reason to read this
  document).  This HOWTO will not answer all possible questions you
  might have about Beowulf, but hopefully will give you ideas and guide
  you in the right direction.  The purpose of this HOWTO is to provide
  background information, links and references to more advanced
  documents.


  2.2.  What is a Beowulf ?

  Famed was this Beowulf: far flew the boast of him, son of Scyld, in
  the Scandian lands.  So becomes it a youth to quit him well with his
  father's friends, by fee and gift, that to aid him, aged, in after
  days, come warriors willing, should war draw nigh, liegemen loyal: by
  lauded deeds shall an earl have honor in every clan. Beowulf is the
  earliest surviving epic poem written in English.  It is a story about
  a hero of great strength and courage who defeted a monster called
  Grendel.  See ``History'' to find out more about the Beowulf hero.

  There are probably as many Beowulf definitions as there are people who
  build or use Beowulf Supercomputer facilities.  Some claim that one
  can call their system Beowulf only if it is built in the same way as
  the NASA's original machine.  Others go to the other extreme and call
  Beowulf any system of workstations running parallel code.  My
  definition of Beowulf fits somewhere between the two views described
  above, and is based on many postings to the Beowulf mailing list:


  Beowulf is a multi computer architecture which can be used for
  parallel computations.  It is a system which usually consists of one
  server node, and one or more client nodes connected together via
  Ethernet or some other network.  It is a system built using commodity
  hardware components, like any PC capable of running Linux, standard
  Ethernet adapters, and switches.  It does not contain any custom
  hardware components and is trivially reproducible.  Beowulf also uses
  commodity software like the Linux operating system, Parallel Virtual
  Machine (PVM) and Message Passing Interface (MPI).  The server node
  controls the whole cluster and serves files to the client nodes.  It
  is also the cluster's console and gateway to the outside world.  Large
  Beowulf machines might have more than one server node, and possibly
  other nodes dedicated to particular tasks, for example consoles or
  monitoring stations.  In most cases client nodes in a Beowulf system
  are dumb, the dumber the better.  Nodes are configured and controlled
  by the server node, and do only what they are told to do.  In a disk-
  less client configuration, client nodes don't even know their IP
  address or name until the server tells them what it is.  One of the
  main differences between Beowulf and a Cluster of Workstations (COW)
  is the fact that Beowulf behaves more like a single machine rather
  than many workstations.  In most cases client nodes do not have
  keyboards or monitors, and are accessed only via remote login or
  possibly serial terminal.  Beowulf nodes can be thought of as a CPU +
  memory package which can be plugged in to the cluster, just like a CPU
  or memory module can be plugged into a motherboard. 5/12/92


  Beowulf is not a special software package, new network topology or the
  latest kernel hack.  Beowulf is a technology of clustering Linux
  computers to form a parallel, virtual supercomputer.  Although there
  are many software packages such as kernel modifications, PVM and MPI
  libraries, and configuration tools which make the Beowulf architecture
  faster, easier to configure, and much more usable, one can build a
  Beowulf class machine using standard Linux distribution without any
  additional software.  If you have two networked Linux computers which
  share at least the /home file system via NFS, and trust each other to
  execute remote shells (rsh), then it could be argued that you have a
  simple, two node Beowulf machine.



  2.3.  Classification

  Beowulf systems have been constructed from a variety of parts.  For
  the sake of performance some non-commodity components (i.e. produced
  by a single manufacturer) have been employed.   In order to account
  for the different types of systems and to make discussions about
  machines a bit easier, we propose the following simple classification
  scheme:

  CLASS I BEOWULF:

  This class of machines built entirely from commodity "off-the-shelf"
  parts.  We shall use the "Computer Shopper" certification test to
  define commodity "off-the-shelf" parts.  (Computer Shopper is a 1 inch
  thick monthly magazine/catalog of PC systems and components.) The test
  is as follows:

  A CLASS I Beowulf is a machine that can be assembled from parts found
  in at least 3 nationally/globally circulated advertising catalogs.

  The advantages of a CLASS I system are:

  o  hardware is available form multiple sources (low prices, easy
     maintenance)

  o  no reliance on a single hardware vendor

  o  driver support from Linux commodity

  o  usually based on standards (SCSI, Ethernet, etc.)

  The disadvantages of a CLASS I system are:

  o  best performance may require CLASS II hardware

  CLASS II BEOWULF

  A CLASS II Beowulf is simply any machine that does not pass the
  Computer Shopper certification test.  This is not a bad thing.
  Indeed, it is merely a classification of the machine.

  The advantages of a CLASS II system are:

  o  Performance can be quite good!

  The disadvantages of a CLASS II system are:
asd
asd